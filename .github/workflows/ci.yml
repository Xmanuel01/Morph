name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy
      - uses: Swatinem/rust-cache@v2
      - name: Format
        run: cargo fmt --check --all
      - name: Clippy
        run: cargo clippy --workspace --all-targets --all-features -- -D warnings
      - name: Test
        run: cargo test --workspace
  package-check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - uses: Swatinem/rust-cache@v2
      - name: Build release binaries
        run: |
          cargo build -p enkai --release
          cargo build -p enkai_native --release
      - name: Package and verify
        run: |
          VERSION="0.0.0"
          BIN="target/release/enkai"
          LEGACY_BIN="target/release/enkai"
          NATIVE="target/release/libenkai_native.so"
          OUT="dist/enkai-${VERSION}-linux-x86_64.tar.gz"
          STAGE="dist/stage"
          rm -rf "$STAGE"
          mkdir -p "$STAGE/examples"
          cp "$BIN" "$STAGE/enkai"
          chmod +x "$STAGE/enkai"
          if [ -f "$LEGACY_BIN" ]; then
            cp "$LEGACY_BIN" "$STAGE/enkai"
            chmod +x "$STAGE/enkai"
          fi
          cp -R std "$STAGE/std"
          cp -R examples/hello "$STAGE/examples/hello"
          cp install/README.txt "$STAGE/README.txt"
          if [ -f "$NATIVE" ]; then
            cp "$NATIVE" "$STAGE/"
          fi
          mkdir -p dist
          tar -czf "$OUT" -C "$STAGE" .
          tar -tzf "$OUT" | grep -q "^enkai$"
          tar -tzf "$OUT" | grep -q "^README.txt$"
          tar -tzf "$OUT" | grep -q "^std/"
          tar -tzf "$OUT" | grep -q "^examples/hello/main.enk$"
          if tar -tzf "$OUT" | grep -q "^libenkai_native.so$"; then
            true
          tar -tzf "$OUT" | grep -q "^libenkai_native.so$"
          EXTRACT="dist/extract"
          rm -rf "$EXTRACT"
          mkdir -p "$EXTRACT"
          tar -xzf "$OUT" -C "$EXTRACT"
          (cd "$EXTRACT" && ./enkai --version)
          (cd "$EXTRACT" && ./enkai run examples/hello/main.enk)
  torch:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"
      - name: Install PyTorch CPU
        run: |
          python -m pip install --upgrade pip
          python -m pip install torch==2.2.0+cpu --index-url https://download.pytorch.org/whl/cpu
      - uses: dtolnay/rust-toolchain@stable
      - uses: Swatinem/rust-cache@v2
      - name: Test enkai_tensor with torch
        env:
          LIBTORCH_USE_PYTORCH: "1"
          PYTHON_SYS_EXECUTABLE: python
        run: |
          TORCH_LIB_DIR=$(python -c "import os, torch; print(os.path.join(os.path.dirname(torch.__file__), 'lib'))")
          export LD_LIBRARY_PATH="$TORCH_LIB_DIR:${LD_LIBRARY_PATH:-}"
          cargo test -p enkai_tensor --features torch --tests retain_counts --tests leak_check --tests backend_api --tests amp_handles --tests checkpoint_ranked

  torch-gpu:
    # Requires a self-hosted runner with CUDA + NCCL + GPU drivers installed.
    runs-on: [self-hosted, linux, gpu]
    env:
      LIBTORCH_USE_PYTORCH: "1"
      PYTHON_SYS_EXECUTABLE: python
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"
      - name: Install PyTorch CUDA
        run: |
          python -m pip install --upgrade pip
          python -m pip install torch==2.2.0+cu121 --index-url https://download.pytorch.org/whl/cu121
      - uses: dtolnay/rust-toolchain@stable
      - uses: Swatinem/rust-cache@v2
      - name: Run GPU/NCCL tests
        run: |
          TORCH_LIB_DIR=$(python -c "import os, torch; print(os.path.join(os.path.dirname(torch.__file__), 'lib'))")
          export LD_LIBRARY_PATH="$TORCH_LIB_DIR:${LD_LIBRARY_PATH:-}"
          cargo test -p enkai_tensor --features "torch,dist" --tests backend_api --tests backend_cpu_ops --tests backend_rank_device --tests leak_check --tests retain_counts --tests amp_handles --tests checkpoint_ranked

  tensor-no-torch:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - uses: Swatinem/rust-cache@v2
      - name: Check enkai_tensor without torch
        run: cargo check -p enkai_tensor --no-default-features

  docker:
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Compute tags
        id: vars
        run: |
          IMAGE=ghcr.io/${{ github.repository }}
          TAGS="$IMAGE:sha-${{ github.sha }}"
          if [ "${{ github.ref_type }}" = "branch" ] && [ "${{ github.ref_name }}" = "main" ]; then
            TAGS="$TAGS,$IMAGE:latest"
          fi
          if [ "${{ github.ref_type }}" = "tag" ]; then
            TAGS="$TAGS,$IMAGE:${{ github.ref_name }}"
          fi
          echo "tags=$TAGS" >> "$GITHUB_OUTPUT"
      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.vars.outputs.tags }}
